```mermaid
graph LR
A[mvn 命令] --> B1[clean]
A --> B2[compile]
A --> B3[package]
A --> B4[install]
A --> B5[deploy]

A --> C1[-pl 指定模块]
A --> C2[-am 同时构建依赖模块]
A --> C3[-amd 同时构建依赖此模块的模块]
A --> C4[-rf 从指定模块恢复构建]
A --> C5[-DskipTests 跳过测试]
A --> C6[-U 更新快照]
A --> C7[-T 多线程构建]
A --> C8[-D 自定义属性]

```



### 命令 mvn clean package -pl ruoyi-system -am





```mermaid


graph TD
    A[mvn clean package -pl ruoyi-system -am] --> B[clean: 清理 target 目录]
    B --> C[分析 ruoyi-system 模块依赖关系]
    C --> D[同时构建依赖模块ruoyi-common]
    D --> E[执行 compile  test  package 生命周期阶段]
    E --> F[调用 spring-boot-maven-plugin:repackage]
    F --> G[生成 ruoyi-system.jar]

```



### package vs repackage

```mermaid
flowchart TB
  subgraph CLI["命令"]
    A[mvn package]
    B[mvn spring-bootrepackage]
  end
  
  A --> |执行到 package 阶段| PHASE[package lifecycle phase]

  PHASE --> |默认由| JAR[maven-jar-plugin:jar 或 maven-war-plugin:war]
  PHASE --> |若配置了 spring-boot 插件 execution | REPK[spring-boot-maven-plugin:repackage]

  B --> |显式调用 plugin goal | REPK

  note right of PHASE
    1) package 会触发 lifecycle 到 package。2) 若 spring-boot 的 repackage 被绑定到 package，则在 package 阶段会执行 repackage。
  end

```

### `maven-compiler-plugin` 的 goals

```mermaid
graph TD
    A[maven-compiler-plugin] --> B(compile)
    A --> C(testCompile)

    B --> B1[编译 src/main/java 下的源码]
    B --> B2[输出到 target/classes 目录]

    C --> C1[编译 src/test/java 下的测试源码]
    C --> C2[输出到 target/test-classes 目录]

```



### `spring-boot-maven-plugin` 的 goals

```mermaid
graph TD
    A [spring-boot-maven-plugin] --> B(repackage)
    A --> C(run)
    A --> D(build-image)
    A --> E(start / stop)

    B --> B1[把已有 JAR 包重新打包为可执行 JAR]
    B --> B2[加入依赖和 Spring Boot Loader]

    C --> C1[直接运行 Spring Boot 应用]
    C --> C2[常用于开发调试]

    D --> D1[构建 OCI / Docker 镜像]
    D --> D2[集成 Cloud Native Buildpacks]

    E --> E1[启动 Spring Boot 应用（后台模式）]
    E --> E2[停止 Spring Boot 应用（后台模式）]

```

